<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java虚拟机学习笔记 | 郑拓铭博客]]></title>
  <link href="http://TuomingZheng.github.io/blog/categories/javaxu-ni-ji-xue-xi-bi-ji/atom.xml" rel="self"/>
  <link href="http://TuomingZheng.github.io/"/>
  <updated>2015-01-13T00:40:22+08:00</updated>
  <id>http://TuomingZheng.github.io/</id>
  <author>
    <name><![CDATA[TuomingZheng]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java Virtual Machine垃圾收集器]]></title>
    <link href="http://TuomingZheng.github.io/blog/2014/11/05/java-virtual-machinela-ji-shou-ji-qi/"/>
    <updated>2014-11-05T23:47:34+08:00</updated>
    <id>http://TuomingZheng.github.io/blog/2014/11/05/java-virtual-machinela-ji-shou-ji-qi</id>
    <content type="html"><![CDATA[<blockquote><p>垃圾收集器是虚拟机内存回收的具体实现，不同Java虚拟机的垃圾收集器存在很大的区别。用户甚至可以组合各个年代所使用的垃圾收集器。</p></blockquote>

<p>
    接下来将分别列出常见的几个垃圾收集器原理以及他们的特点。`
</p>


<h1>Serial收集器</h1>


<p>
Serial收集器是历史最为悠久的垃圾收集器，这个收集器是一个单线程的垃圾收集器。该收集器不仅仅只会使用一个CPU或则一个线程去进行
垃圾收集工作，在他进行垃圾收集操作时必须暂停其他所有的工作线程。
</p>


<p>
Serial收集器的特点是简单而且高效，对于限定单个CPU环境时，Serial收集器由于没有线程交互的开销，可以获得最高的单线程收集效率。
Serial收集器是Client模式下虚拟机收集器的一个很好的选择。
</p>




<h1>ParNew收集器</h1>


<p>
ParNew收集器与Serial收集器的不同之处是ParNew收集器采用多线程进行垃圾收集操作，该收集器是Server模式下虚拟机中首选的新生代收集器。
在单CPU环境下ParNew收集器由于线程交互的开销，效果没有Serial收集器理想。
</p>


<p><strong>并行</strong>：<em>垃圾收集线程并行工作，而用户线程处于等待状态。</em></br>
<strong>并发</strong>: <em>用户线程和垃圾收集线程同时执行，用户程序在继续运行而垃圾收集程序运行在另一个CPU上。</em></p>

<h1>Parallel Scavenge收集器</h1>


<p>
    Parallel Scavenge收集器是一个新生代垃圾收集器，使用复制算法进行新生代的垃圾收集。同时Parallel Scavenge收集器也是个并行的
多线程收集器。Parallel Scavenge收集器的目标是达到一个可控制的吞吐量，吞吐量高可以高效率的利用CPU时间尽快完成程序运算任务，
主要适合在后台运算而不需要交互的任务。
</p>


<p>
Parallel Scavenge收集器提供两个参数-XX:MaxGCPauseMillis参数和-XX:GCTimeRatio参数设置最大垃圾收集停顿时间和设置吞吐量大小。
MaxGCpauseMillis参数可以设置为大于0的毫秒数，收集器将尽可能保证内存回收的时间不超过设定的值。GCTimeRatio参数的值是大于0且小于
100的整数，该参数设置的值是吞吐量的倒数。
</p>


<p><strong>吞吐量</strong></br>
<em>吞吐量是指CPU运行用户代码的时间与CPU消耗时间的比值，吞吐量=运行用户代码时间/（运行用户代码时间 + 垃圾收集时间）。</em></p>

<h1>Serial Old收集器</h1>


<p>
Serial Old收集器是老年代版本，他同样是一个单线程收集器，他使用“标记-整理”算法，这个收集器一般在Client模式下的虚拟机中使用。
</p>


<p>
该垃圾收集器在Server模式下的两大用途：</br>
1). 在JDK1.5之前的版本与Parallel Scavenge收集器配合使用，Parallel Scavenge垃圾收集器负责新生代垃圾收集，而Serial Old负责老年
代的垃圾收集。</br>
2). 作为CMS垃圾收集器在并发收集时Concurrent Mode Failure时使用的后备垃圾收集器。
</p>




<h1>Parallel Old收集器</h1>


<p>
    Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程“标记-整理”算法。在Parallel Old收集器出现之前，新生代
垃圾收集器Parallel Scavenge只能与老年代的Serial Old收集器配合使用导致在Server端整体吞吐量不高。在Parallel Old收集器出现后可以
和Parallel Scavenge收集器配合使用提供吞吐量。
</p>




<h1>CMS收集器</h1>


<p>
CMS收集器是一款以获取最短停顿时间为目标的收集器，该收集器是基于“标记-整理”算法实现，它的运作过程中包括四个过程。他们分别是“初始
标记”、“并发标记”、“重新标记”和“并发清除”四个阶段。其中“初始标记”、“重新标记”两个阶段需要“Stop The World”。“初始标记”仅仅是标记
一下GC Root能直接关联到的对象，“并发标记”就是进行GC RootsTracing过程，而“重新标记”则是为了修正并发标记期间用户程序继续运行而导致
标记产生变动的那一部分对象标记记录。
</p>


<p><p>
CMS垃圾收集器的明显缺点：</br>
1). CMS收集器对CPU资源十分敏感，在并发阶段不会导致用户线程停顿，但是会占用一部分线程而导致应用程序变慢，总吞吐量下降。</br>
2). CMS收集器无法处理浮动垃圾，可能出现一次&#8221;Concurrent Mode Failure&#8221;失败而导致一次Full GC的产生。浮动垃圾就是CMS在“并发清理”阶段
由于用户线程还在运行，产生新垃圾。而这部分垃圾在标记过程之后，CMS无法在单次收集中处理他们，只好留到下一次GC时清理掉。</br>
3). CMS收集器基于“标记-清除”算法思想，而这意味着垃圾收集结束后会产生大量的空间碎片。
<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Virtual Machine内存分配]]></title>
    <link href="http://TuomingZheng.github.io/blog/2014/11/05/java-virtual-machinenei-cun-fen-pei/"/>
    <updated>2014-11-05T23:44:35+08:00</updated>
    <id>http://TuomingZheng.github.io/blog/2014/11/05/java-virtual-machinenei-cun-fen-pei</id>
    <content type="html"><![CDATA[<blockquote><p>Java虚拟机内存管理的两个方面是对象内存的分配和对象内存的回收，在之前的笔记中已经记录
了Java虚拟机的对象内存回收方面的基本内容。</p></blockquote>

<p>
    对象的分配主要是在Java虚拟机的堆空间进行分配，一般是分配在新生代的Eden区上，如果启动了本地线程
分配缓存，将按线程分配在TLAB上，少数情况下也可能分配在老年代上。
</p>


<h1>对象分配在Eden区上</h1>


<p>
在大多数情况下，对象在新生代Eden区分配，在Eden区没有足够的空间时虚拟机将进行一次Minor GC。在发生Minor
GC时如果Survivor没有足够的空间容纳Eden区没有被回收的对象时将直接分配到老年代。
<li>Minor GC</li>
<p>Minor GC是新生代垃圾收集动作，在新生代的Java对象大都具有朝生夕死的特点，所以Minor GC发生比较频繁。</p>
<li>Major GC</li>
<p>Major GC是老年代发生的垃圾收集动作，在老年代垃圾收集动作发生时一般伴随至少一次的Minor GC。</p>
</p>


<h1>大对象进入老年代</h1>


<p>
Java大对象指需要连续大量内存空间的Java对象，大对象容易导致内存还有不少空间时就提前触发垃圾收集来获得足够的空间
来容纳他们。Java虚拟机提供参数&#8221;-XX:PretenureSizeThreshold&#8221;指明当对象所需的内存空间大于这个值时将直接在老年代分
配。
</p>


<h1>长期存活的对象进入老年代</h1>


<p>
虚拟机给每个对象定义一个对象年龄计数器，如果对象在Eden区出生并经过第一次Minor GC后仍然存活并且能够被Survivor容纳
的话，将被移动到Survivor并且对象年龄设置为1。对象在Survivor中内经历一次Minor GC，对象年龄计数器加一，在对象年龄
计数器值到一定值时将移动到老年代。
</p>


<h1>动态对象年龄判定</h1>


<p>
如果Survivor空间中相同年龄的所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，
无需等到MaxTenuringThreshold中要求的年龄。
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Virtual Machine内存回收机制]]></title>
    <link href="http://TuomingZheng.github.io/blog/2014/11/05/java-virtual-machinenei-cun-hui-shou-ji-zhi/"/>
    <updated>2014-11-05T23:28:56+08:00</updated>
    <id>http://TuomingZheng.github.io/blog/2014/11/05/java-virtual-machinenei-cun-hui-shou-ji-zhi</id>
    <content type="html"><![CDATA[<blockquote><p>谈起Java虚拟机就不得不提到GC，GC所要完成的事情包括确定哪些内存需要回收、什么时候回收和如何回收需要回收的内存。</p></blockquote>

<p>
    Java虚拟机内存回收主要是针对Java堆和方法区，而具有与线程同样生命周期的程序计数器、虚拟机栈和本地方法栈的内存
分配和回收具备确定性而无需过多的考虑。接下来将按照GC所要完成的事情分别整理如下：
</p>


<h1>确定需要回收的内存</h1>


<h2>Java堆需要回收的内存的确定</h2>


<p><li>引用计数法</li></p>

<p>
    引用计数法的基本思路是，给对象添加一个引用计数器，在有地方引用到该对象时计数器加一，在取消引用时该对象的引用
计数器减一，在对象的引用计数器的值为零时确定回收该对象。引用技术法思路简单，但无法很好的解决对象之间的循环引用问
题，在主流的Java虚拟机内没有采用该方法来确定需要回收的对象。
</p>


<p><li>可达性分析算法</li></p>

<p>
    可达性分析算法就是从被称为GC Root的对象开始向下搜索，搜索所经过的节点形成的路径称为引用链。如果一个对象无法
从GC Root开始搜索到，那么该对象确定可以被回收。算法的基本思路类似于图论里顶点可达性问题的求解，主流的Java虚拟机
采用该方法来确定可以被回收的对象。
</P>


<p>
    在Java语言中可以被认定为GC root的对象如下：</br>
    1. 虚拟机栈中引用的对象。</br>
    2. 方法区中类静态属性引用的对象。</br>
    3. 方法区中常量引用的对象。</br>
    4. 本地方法栈中引用的对象</br>
</p>


<p><strong>引用分类</strong></br></br>
<em>在Java虚拟机中将reference类型定义为数据中存储的数值代表的是另一块内存的起始地址。Java语言的引用分为四类，
他们分别是强引用、软引用、弱引用和虚引用。</em></br></p>

<ul>
1. 强引用，强引用还存在，对象不会被回收。</br>
2. 软引用，在系统发生内存溢出时将对象列入回收范围进行第二次回收。</br>
3. 弱引用，弱引用关联到的对象，在下一次内存回收时将会回收只被弱引用关联到的对象。</br>
4. 虚引用，虚引用的存在不对生存时间构成影响，无法通过通过虚引用取得一个对象实例。</br>
</ul>


<p><strong>对象生死</strong></br></br>
<strong>对于通过可达性判定算法确定可以回收的对象也不一定会被回收，对于通过可达性算法判定没有与GC Root相连接的引用链
的对象则会被第一次标记并且筛选是否有必要执行<code>finalize()</code>方法，如果对象没有重写<code>finalize()</code>
方法或则该方法已经被虚拟机执行过，将其视为“没有必要执行”。如果对象被判定为有必要执行<code>finzlize()</code>方法，
那么对象会被放置在F_Queue队列，在稍后将由Finalizer线程去执行并标记，如果在该方法内没有于引用链上的任何一个对象
建立关联那么对象将会被回收。</strong></p>

<h2>方法区回收的确定</h2>


<ul>
    方法区内垃圾收集主要是针对废弃常量和无用的类。如果方法区内没有其他地方引用该常量那么该常量将会被回收。对于
无用的类的判定需要确认以下几个方面：</br>
    1. 该类的实例都已经被回收了，Java堆不存在该类的实例。</br>
    2. 加载该类的ClassLoader已经被回收。</br>
    3. 该类的Class对象没有在任何地方被引用。</br>
</ul>


<h1>垃圾收集算法思想</h1>


<p><li>标记-清除算法</li></p>

<p>
    “标记-清除”算法是最基本的垃圾收集算法，整个过程分为“标记”和“清除”两个过程。首先标记所有需要回收的对象，在标记
结束后统一回收所有被标记的对象。“标记-清除”算法有两个不足之处为，标记和清除两个过程效率都不高，该算法在清除之后会
产生大量的内存碎片，空间碎片太多导致以后程序运行过程中需要分配较大的对象时需要提前触发一次垃圾收集动作。
</p>


<p><li>复制算法</li></p>

<p>
复制算法将内存分割成两个部分，每次只使用其中的一块。在当前使用的这一块内存用完时，将还存活的对象复制到另一块内存，
并回收原来的那一块空间。每次内存回收时只对部分内存空间进行回收，在内存分配时不用考虑内存碎片问题，只需要移动堆顶
指针按顺序分配内存。商业虚拟机在新生代都采用这种算法来回收新生代内存。
</p>


<p><li>标记-整理算法</li></p>

<p>
“标记-整理”算法常用在老年代内存回收，算法将整个过程分解为两个阶段。第一个阶段为“标记”过程，在该阶段标记需要被回收的
对象，在“整理”阶段将存活的对象都移动到一端，直接清理掉边界以外的内存。该算法与“标记-清除”算法的区别是在第二个阶段需
要将存活的对象整理成一块连续的内存，类似于磁盘整理技术。
</p>


<p><li>分代收集算法</li></p>

<p>
这种算法思想将根据内存对象存活周期的不同将内存划分为若干块，一般把Java堆分解为新生代和老年代，根据各个年代的不同分别
采取不同的回收算法。例如，在新生代采用“复制”算法，而在老年代采用“标记-整理”算法等。
</p>


<h1>何时回收内存</h1>


<h2>枚举根节点</h2>


<p>
可达性分析算法在确定哪些对象可以被回收时，需要保证整个内存冻结起来，需要在一个一致的内存快照上分析。这点导致了在
GC时需要停顿所有Java执行线程，如果在判定哪些对象可以被回收需要一个不漏的检查所有执行上下文和全局引用位置，那么停顿
所需的时间将会很长，在实际实现中使用称为OopMap的数据结构来快速进行可达性分析，在类加载完成的时候虚拟机将类对象内在
各个偏移量上是什么类型数据计算出来，在特定的位置记录栈和寄存器中那些位置是引用。
</p>


<h2>安全点</h2>


<p>
虚拟机没有为每条指令都生成一个OopMap数据结构，虚拟机只在称为“安全点”的位置记录这些信息，程序在执行时并非在所有地方
都可以停顿下来进行内存回收，只有在“安全点”才能停顿。“安全点”的选定以“是否具有让程序长时间执行的特征”为标准进行的，
常见的是指令序列复用（方法调用指令、循环跳转指令等）。
</p>


<p>
    GC发生时让执行线程都跑到“安全点”上停顿下来，一般来说有两个方案可供选择：</br>
    1. 抢先式中断，在GC发生时所有线程全部中断，如果有线程中断的地方不在“安全点”上则恢复线程，让其运行到“安全点”上。</br>
    2. 主动式中断，在GC时不需要直接对线程操作，简单的设置一个标志。各个线程执行时主动去轮询这个标志，发现标志为真时就
    中断自己。
</p>


<h2>安全区</h2>


<p>
    安全区是指在一段代码片段中，引用关系不会发生变化，在这个区域任何地方开始GC是安全的。安全区域是针对未处于执行状态的线程
的，线程在进入“安全区”时将标志自己进入“安全区”（这时GC检查到这个标志就不用理会这个线程了），在离开“安全区”时间检查系统是否
完成根节点的枚举，如果已经完成那么线程继续执行否则等待直到收到离开“安全区”的信号。
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Virutal Machine内存区域]]></title>
    <link href="http://TuomingZheng.github.io/blog/2014/11/05/java-virutal-machinenei-cun-qu-yu/"/>
    <updated>2014-11-05T23:19:55+08:00</updated>
    <id>http://TuomingZheng.github.io/blog/2014/11/05/java-virutal-machinenei-cun-qu-yu</id>
    <content type="html"><![CDATA[<blockquote><p>Java虚拟机自动内存管理技术使得我们不用再像使用C++那样纠结于内存分配回收问题。但是这并不意味着Java程序不存在内存泄漏问题。
而在Java程序内存泄漏时，我们必须清楚了解Java虚拟机的内存区域才能高效的解决掉内存泄漏问题和OOM问题。</p></blockquote>

<h1>Java虚拟机运行时数据区域</h1>


<p>
    Java虚拟机将Java程序运行时的内存区域划分为若干个不同类型的区域。这些区域的用途、创建时间和销毁时间都有各自的特点，有些
是与线程的生命周期紧密相关的，而有些数据区域却与进程的生命周期相关的。接下来将按照区域的创建和销毁的时间，分别罗列这些区域：
</p>




<ul>
    <h2>线程私有的内存区域</h2>
    <li>
        程序计数器
    </li>
    <p>
        程序计数器(PC)是当前线程所执行的字节码行号指示器，它是一块较小的内存区域。该内存区域为各个线程所有，每个线程的程序
        计数器互不影响对方，在切换线程执行时也将切换线程计数器。这里的程序计数器仅仅指向Java程序对应的字节码行号，在程序执行
        native代码时，程序计数器的值为空。
    </p>
    <li>Java虚拟机栈</li>
    <p>
        Java虚拟机栈也是线程私有的内存区域，每个Java方法在执行时都会在该执行线程的Java虚拟机栈内创建一个栈帧并且其push为栈
        顶元素，在方法执行结束时该栈帧pop出执行线程的Java虚拟机栈。Java方法的栈帧内包含有局部变量表、操作数栈、动态链接和
        方法返回地址等信息。
    </p>
    <p>
        Java虚拟机栈常见的异常有StackOverflowError和OutOfMemoryError两种，其中如果线程请求的栈的深度超过Java虚拟机所允许的
        最大深度将抛出StackOverflowError，程序中如果存在方法的递归调用并且无法满足递归出口条件时会导致该问题发生。如果Java
        虚拟机栈运行动态扩展的话，在Java虚拟机栈无法得到内存空间进行扩展时将会抛出OutOfMemoryError异常。
    </p>
    <li>本地方法栈</li>
    <p>
        本地方法栈与Java虚拟机栈的区别是本地方法栈是为native方法服务的，本地方法栈也有StackOverflowError和OutOfMemoryError
        两个异常情形。在一些虚拟机中甚至将Java虚拟机栈和本地方法栈合二为一。
    </p>

    <p>
        以上这些虚拟机内存区域都是线程私有的，不同的线程将拥有不同的内存区域。直观的说分配在这些区域的数据不可能被多个用户
        线程所共享，也就不存在并发同步引起的问题了。
    </p>
</ul>




<ul>
    <h2>进程所有的内存区域</h2>
    <li>Java堆</li>
    <p>
        Java堆是Java应用程序内使用空间比较大的一块内存区域，该内存区域的生命周期与进程是同步的。在虚拟机启动是创建该区域，该
        区域的目的是存放Java对象。Java堆空间可以实现为固定大小，也可以实现为可以动态扩展。实现为动态扩展时可以通过-Xmx和-Xms
        配置Java堆空间的最大值和最小值，在无法使用堆空间为Java对象分配空间时将抛出OutOfMemoryError异常。这里所讨论的Java堆空
        间只是操作系统的虚拟地址空间，对于实现虚拟内存功能的操作系统来说，给Java堆分配的物理地址空间可能是不连续的。
    </p>
    <li>方法区</li>
    <p>
        在Java虚拟机规范里将方法区列为Java堆的一部分，方法区的一个别名是Non-Heap。方法区是各个用户线程共享的内存区域，所以存储
        在该区域的数据在多线程并发时也会有同步问题。该区域用于存储被虚拟机加载的类信息、常量、静态变量和编译后形成的代码。方法
        区也不需要连续的内存空间，支持固定大小和可动态扩张两种方式，甚至可以选择不同的垃圾回收机制。该内存区域的垃圾收集主要是
        针对常量池和类型的卸载。在无法继续分配方法区空间时也将抛出OutOfMemoryError。
    </p>
    <li>运行时常量池</li>
    <p>
        运行时常量池是方法区的一部分，该区域存放的是类加载进虚拟机时class文件内的常量池，主要是编译形成的字面量和符号引用。运行
        时常量池与class文件内的常量池的区别是运行时常量池可以在程序运行期间将新的常量放入其中。运行时常量池受方法区的限制，在空
        间不够分配时也将抛出OutOfMemoryError。
    </p>
    <li>直接内存</li>
    <p>
        直接内存不是Java虚拟机运行时数据区的一部分，但这部分内存也会有OutOfMemoryError问题。这些主要是使用native函数直接分配Java
        堆外的内存，比如Java NIO。直接内存不会受Java堆的大小限制但是会受操作系统为每个进程分配的地址空间大小的限制。
    </p>
</ul>



]]></content>
  </entry>
  
</feed>
